generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String   @id @default(cuid())
  email             String   @unique
  name              String?
  passwordHash      String
  companyName       String?
  resetToken        String?
  resetTokenExpiry  DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  role              String   @default("user")
  account_id        String?
  account           Account? @relation(fields: [account_id], references: [account_id])
  emailVerified     DateTime?
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  email     String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())
}

model EmailVerificationToken {
  id        String   @id @default(uuid())
  email     String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())
}

/// Company account model
model Account {
  /// Internal numeric sequence to ensure uniqueness and easy increment
  accountSeq     Int      @id @default(autoincrement())
  /// Public 7-digit zero-padded account identifier
  account_id     String?  @unique
  company_name   String
  company_domain String
  owner_email    String
  created_at     DateTime @default(now())
  /// Back relation to users under this account
  users          User[]
  contacts       Contact[]
  companies      Company[]
  deals          Deal[]
  passwordVault  PasswordVault?
}

model Contact {
  id           String   @id @default(cuid())
  accountSeq   Int
  account      Account  @relation(fields: [accountSeq], references: [accountSeq])
  name         String
  email        String
  phone        String?
  company      String?
  owner        String?  @default("Unassigned")
  status       String   @default("New")
  createdAt    DateTime @default(now())
  lastActivity DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([accountSeq])
}

model Company {
  id           String   @id @default(cuid())
  accountSeq   Int
  account      Account  @relation(fields: [accountSeq], references: [accountSeq])
  name         String
  domain       String?
  industry     String?
  size         String?
  owner        String?  @default("Unassigned")
  status       String   @default("New")
  createdAt    DateTime @default(now())
  lastActivity DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([accountSeq])
}

model Deal {
  id           String   @id @default(cuid())
  accountSeq   Int
  account      Account  @relation(fields: [accountSeq], references: [accountSeq])
  name         String
  company      String?
  amount       Float    @default(0)
  owner        String?  @default("Unassigned")
  stage        String   @default("New")
  status       String   @default("Open")
  createdAt    DateTime @default(now())
  lastActivity DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([accountSeq])
}

/// Encrypted password vault per account. Stores only encrypted data, never raw passwords.
model PasswordVault {
  id           String   @id @default(cuid())
  accountSeq   Int      @unique
  account      Account  @relation(fields: [accountSeq], references: [accountSeq])

  /// Base64-encoded AES-GCM cipher text
  cipher       String
  /// Base64-encoded IV used for AES-GCM
  iv           String
  /// Base64-encoded PBKDF2 salt
  salt         String

  /// Timestamp (ms since epoch) from the client when this vault was last updated
  lastUpdated  BigInt
  /// Number of entries in the vault at last update
  entryCount   Int

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([accountSeq])
}

